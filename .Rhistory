above(x,12)
above <- function(x,n =10){
use <- x > n
x[use]
}
above(x)
?numeric
columnmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc)
{
means[i] <- mean(y[,i])
}
means
}
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE ){
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc)
{
means[i] <- mean(y[,i], na.rm = removeNA)
}
means
}
columnmean(airquality)
?na.rm
args(lm)
paste("a","b", sep = ":")
q()
23%%100
3%%2
3%%3
12>99
datos =  data.frame(
estatura =  c(1.78, 1.70, 1.72, 1.76),
peso = c(170, 164, 180, 178),
row.names = c("Kleber", "Marco", "Danys", "Stanley"))
datos
sum(datos)
sumary(datos)
summary(datos)
datos =  data.frame(
estatura =  c(1.78, 1.70, 1.72, 1.76),
peso = c(170, 164, NA, 178),
row.names = c("Kleber", "Marco", "Danys", "Stanley"))
datos
summary(datos)
datos$estatura
datos$peso
datos[3,2] = 200
datos
datos$peso[3] = 180
datos
x= factor(c(1,3,2,4,1,2,4,3,1,3),
labels = c("verde", "azul", "rojo", "amarillo"))
table(x)
plot(x)
plot(datos$peso)
plot(peso~estatura, data = datos)
datos$provincia =  factor(c(1,1,2,2), labels = c("Tungurahua","Manabi"))
datos
plot(peso~provincia, data = datos)
summary(datos)
datos[5,] = c(1.85, 250, "Manabi")
datos
row.names(datos)[5] = "Francisco"
datos
str(datos)
mode(datos$estatura) = "numeric"
mode(datos$peso) = "numeric"
str(datos)
datos = datos[-5,]
datos
datos["Francisco",] =  list(1.85,250, "Manabi")
datos
plot(peso~provincia, data = datos)
boxplot(datos$peso)
seq(1,5, by = 0.2)
seq(1,5, length = 20)
curve(x^2, from =-3, to = 3)
curve(sin, from =-2*pi, to = 2*pi)
text(-3,0.5,"hola")
q()
q()
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
q()
m <- matrix(seq(1,16), 4, 4) # matriz de 4x4 con los elementos del 1 al 16
m
apply(m, 2, max)# maximo por columnas
apply(m, 1,min)# minimo por filas
apply(m, c(1,2), function(x){x^2})# funcion aplicada tanto a filas como columnas c(1,2)
apply(m, 1, quantile, probs = c(0.4, 0.6, 0.8))# funcion que depende de los parametros
# funcion laplly
x <- 1:3
lapply(x, sqrt)
x <- list(a = 1:10, b = c(1, 10, 100, 1000), c = seq(5,50,5))
x
lapply(x, mean) # genera un vector con las medias de cada uno de los vectores que conforman la lista
sapply(x, mean)
sapply(base[,2:8], summary)
# https://rpubs.com/ydmarinb/apply
q()
history
history()
# funcion lapply
x <- list(a =  1:5, b = rnorm(10))
x
lapply(x, mean)
x <- 1:4
lapply(x,runif)
lapply(x,runif, min = 0, max =  10)
# en el ejemplo anterior se pasa a la funcion lapply los argumentos de la funcion runif
x <- list(a = matrix(,,,) , b = aplicar una función sobre los márgenes de la matriz)
x <- list(a = matrix(1:4,2,2) , b = matrix(1:6,3,2))
x
lapply(x, function(elt) elt[,1] # esta es una funcion anonima para extraer la primera colummna de cada matriz
)
lapply(x, function(elt)elt[2,])# igualmente podemos extraer la segunda fila de cada matriz
x <- list(a = 1:4, b = rnorm(10), c = norm(20,1), d = rnorm(100,5))
x <- list(a = 1:4, b = rnorm(10), cl = norm(20,1), d = rnorm(100,5))
x <- list(a = 1:4, b = rnorm(10), cl = norm(20,1), d = rnorm(100,5))
x <- list(a = 1:4, b = rnorm(10), d = rnorm(100,5),cl = norm(20,1))
x <- list(a = 1:4, b = rnorm(10), c =  rnorm(20,1), d = (100,5))
x <- list(a = 1:4, b = rnorm(10), cl =  rnorm(20,1), d = (100,5))
x
x <- matrix(rnorm(200), 20,10)# funcion apply
x
apply(x,2,mean)
apply(x,2,mean)
apply(x,2,sum)
apply(x,1,mean)
apply(x,1,sum)
x <- matrix(rnorm(200), 20,10)
apply(x, 1 quantile, probs =  c(0.25, 0.75))
apply(x, 1, quantile, probs =  c(0.25, 0.75))
a <- array(rnorm(2 * 2 *2), c(2,2,10))
apply(a, c(1,2), mean)
rowMeans(a, dims = 2)
save.image("D:\\Ciencia de datos\\r\\Apply.R")
q()
load("D:\\Ciencia de datos\\r\\.RData")
s <- list(rep(1,4),rep(2,3),rep(3,2),rep(4,1))
s
mapply(1:4, 4:1)
mapply(rep,1:4, 4:1)
mapply(rep, 1:5, 5:1)
x <- c(rnorm(10),runif(10), rnorm(10,1))
f <- gl(3,10)
f
tapply(x,f,mean)
x
tapply(x,f,mean, simplify  = FALSE)
tapply(x,f,mean, range)
tapply(x,f,range)
x
f
split(x, f)
lapply()split(x,f), mean)
lapply(split(x,f), mean)
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
s
lapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))
s <- split(airquality, airquality$Month)  #  organiza los datos en grupos ordenados por los valores de la columna Month
lapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))   # aplica la funcion colmeans ordeanada por las columnas Solar.R","Wind"
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))
sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")], na.rm = TRUE))
?gl
x <- rnorm(10)
f1 <- gl(2,5)
f2 <- gl(5,2)
f1
f2
interaction(f1,f2)
str(split(x, list(f1,f2)))
str(split(x, list(f1,f2), drop = TRUE))
q()
setwd("D:/Ciencia de datos/r/cache/ProgrammingAssignment2")
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y)  	## set the value of the matrix
{
x <-- y
inv <<- NULL
}
get <- function() x		## get the value of the matrix
setInverse	<- function(solve) inv <<- solve ## set the value of the inverse
getInverse	<- solve	## get the value of the inverse
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse ) ## Return special matrix object
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv))
{
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setInverse(inv)
inv  ## Return a matrix that is the inverse of 'x'
}
# Para definir la matriz B:
a<-c(4,5,4)       # El primer vector.
b<-c(3,4,4)       # El segundo vector.
d<-c(8,7,7)       # El tercer vector.
B<-rbind(a,b,d)    # La matriz B.
B
class(b)
str(b)
class(B)
inver <- solve(B)
inver
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv))
{
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setInverse(inv)
inv  ## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y)  	## set the value of the matrix
{
x <-- y
inv <<- NULL
}
get <- function() x		## get the value of the matrix
setInverse	<- function(solve) inv <<- solve ## set the value of the inverse
getInverse	<- solve	## get the value of the inverse
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse ) ## Return special matrix object
}
mEsp <- makeCacheMatrix(B)
mEsp
inver <- cachesolve(mEsp)
inver <- cacheSolve(mEsp)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y)  	                        ## set the value of the matrix
{
x <-- y
inv <<- NULL
}
get <- function() x		                        ## get the value of the matrix
setInverse	<- function(solve) inv <<- solve    ## set the value of the inverse
getInverse	<- function() inv	                        ## get the value of the inverse
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse ) ## Return special matrix object
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv))
{
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setInverse(inv)
inv  ## Return a matrix that is the inverse of 'x'
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
inver
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y)  	                        ## set the value of the matrix
{
x <-- y
inv <<- NULL
}
get <- function() x		                        ## get the value of the matrix
setInverse	<- function(solve) inv <<- solve    ## set the value of the inverse
getInverse	<- function() inv	                ## get the value of the inverse
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse ) ## Return special matrix object
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv))
{
message("getting cached data")
return(inv)
}
data <- x$get()                                 ## Get the special objec  matrix
inv <- solve(data)                              ## Calculate the inverse matrix
x$setInverse(inv)                               ## set the inverse matrix
inv                                             ## Return a matrix that is the inverse of 'x'
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
inver
inver <- cacheSolve(mEsp)
inver
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
inver
inver <- cacheSolve(mEsp)
inver
makeCacheMatrix <- function(d = matrix()){
d <- NULL
set <- function(matrix){
x <<- y
d <<- NULL
}
get <- function()x
setresolver <- function(solve) d <<- solve
getresolver <- function() d
list(set = set,
get = get,
setresolver = setresolver,
getresolver = getresolver)
}
cacheSolve <- function(x, ...){
d <- x$getresolver()
if(!is.null(d)) {
message("getting cached data")
return(d)
}
data <- x$get()
d <- solve(data, ...)
x$setresolver(d)
d
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinv <- function(inverse) inv <<- inverse
getinv <- function() {inv}
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...){
inv <- x$getinv()
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat,...)
x$setinv(inv)
inv
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
inver
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat)
x$setInverse(inv)
inv
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
inver
inver <- cacheSolve(mEsp)
inver
makeCacheMatrix <- function(x = matrix()) {
## Initialize the inverse property
i <- NULL
## Method to set the matrix
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
## Method the get the matrix
get <- function() {
## Return the matrix
m
}
## Method to set the inverse of the matrix
setInverse <- function(inverse) {
i <<- inverse
}
## Method to get the inverse of the matrix
getInverse <- function() {
## Return the inverse property
i
}
## Return a list of the methods
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## Just return the inverse if its already set
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## Get the matrix from our object
data <- x$get()
## Calculate the inverse using matrix multiplication
m <- solve(data) %*% data
## Set the inverse to the object
x$setInverse(m)
## Return the matrix
m
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## Just return the inverse if its already set
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## Get the matrix from our object
data <- x$get()
## Calculate the inverse using matrix multiplication
m <- solve(data) %*% data
## Set the inverse to the object
x$setInverse(m)
## Return the matrix
m
}
mEsp <- makeCacheMatrix(B)
inver <- cacheSolve(mEsp)
library(datasets)
data(iris)
?iris
head(iris)
sel <- subset(iris, Species == virginica)
sel <- subset(iris, Species == "virginica")
sel
mean(sel$Sepal.Length)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
library(datasets)
data(mtcars)
head(mtcars)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
mean(mtcars$mpg, mtcars$cyl)
mean(mtcars$mpg, mtcars$cyl)
tapply(mtcars$mpg, mtcars$cyl, mean)
sel <- subset(hp, cyl == 4)
sel <- subset(mtcars, cyl == 4)
sel
sel2 <- subset(mtcars, cyl == 8)
mean(sel$hp) - mean(sel2$hp)
debug(ls)
q()
